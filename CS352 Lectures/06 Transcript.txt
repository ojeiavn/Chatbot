SPEAKER 0
Discuss that already. So it's an average. Why is it. So it's really about this. Right. So when you are taking an average of these seven numbers there are three two things you need. It's both the value and the number of times the value comes up. And you see it here. So it will be zero plus zero plus. So if you just naively take the average you just sum them all up and divide by the number. Which is that right. Now we summarise that and it's going to work. Well there are two zeros. Well two over seven are zero. Three over seven is one two over seven is two. So you need these 012. They have different weight in their average.

SPEAKER 1
Oh, I got it. Thank you. Okay. Yeah. Looking at the problem sheets and attempting them. Yes. Do we basically need to call any of the things we proved in analysis, like, let's say the things about one over n converges to zero sort of thing. So the thing about exponential functions.

SPEAKER 0
To be completely honest with you, I don't know exactly what you're doing. Analysis. I sort of know I'll make assumptions if I'm a bit behind. I don't need you to for this class. I don't need you to somehow prove that. Just use it. We know from analysis that this happens, and that's that's good enough. Okay.

SPEAKER 1
Also, finally, you know how when we define the discrete random variable, we said that while it's p of x contains R but not in S. Yes. It's greater than no. Zero. Yes. Is S the discrete beam. The discrete support. The discrete support?

SPEAKER 0
Yes. Well, it's a bit more than it could be. A bit more. We just assume that the it has the component of the zero. All probability of S is one and it's countable. So you could include things that actually have probability zero. So that's why we sort of start inside. But we need that the stability of the discrete space. And.

SPEAKER 1
Look.

SPEAKER 2
Okay, so I'll get started, I suppose. Today we're moving on from talking about the usual theory about management methods. We're moving on to thinking about concepts like lean and agile, which are very much embedded in modern software development. So hopefully you'll find this, this section of the module engaging. And hopefully it's something that you'll do in real life when you when you graduate from here. So lean and agile. But before we do that, let's check if anyone did their homework. So last week I presented lots of examples of things that I wanted you to calculate the earned value from. So which ones were the best and worst at schedule and best and worst at cost? If you didn't do the homework, you have to look very quickly at these figures and try and figure that out. So I'll open the poll now. So I believe it's one of the four options, one of the five options there presented in the poll. The link has always up there in the top corner. Worked at the UK pm for six. So if you if you didn't do the homework, you can't just refer to your your spreadsheet that you did. You probably want to look at the earned value and the planned value columns, and try and figure out if we've earned more value than we've spent, or if we have earned as much value as we'd planned. That's how you get an indication of schedule and cost performance. So when I say the best or the worst performance, I suppose I should maybe mention that I'm talking about the index of performance as opposed to the specific variance calculated. So I guess the ratio, rather than the difference between the values, is the thing that matters here. We're looking at the efficiency in terms of schedule or cost. Okay. We've got 20 responses in. I'm going to assume that's where we're going to stop. So I'll stop the poll now. 22 good. Good job. The last two of you got those in right. So well done. That is correct for most of you. The ones who said DHC H. Why did you say that I wonder? D is not particularly good. Oh, actually, is it good? No it's not. D's not particularly good on schedule. You can see D here. So we planned to have done £37,000 of work and we've we've done £38,000 of work. So I suppose it's £1,000 more work, but as a ratio it's not that great. So hopefully you realise now that the right answer was okay. There are the answers there. So I was using the Spy and the CPI figures to calculate this. So hopefully you can see from that why those are the answer. Does anyone have any issues with that. Did anyone struggle with the seminar last week? All good. Brilliant. All right, let's test you then. Let's see if you're telling the truth. Who remembers the formula that forecasts the estimate of completion? By assuming the remaining work will be completed with the same overall efficiency as the work done so far. So which of these formulae is the correct one? It's the kind of thing you have to remember for the exam. And fortunately, it's not a very complicated equation, but easy to get it wrong. Okay, I'll give you a few more seconds to get your answer in. Okay, I'll stop the poll now. Oh, look at that. That was exciting. Quite, quite a spread there. I suppose it's not exciting. It's it's probably quite depressing. You obviously weren't paying attention last week. The correct answer is, of course, the last one. Okay. The reason being we calculate the estimate of completion by starting with how much we spent so far. We add on that the the cost of the remaining work. This is the cost of the remaining work this term. And we scale that by CSI. Now the top turn there. Is just isn't anything at all. Right. So that one there looks similar to a different equation that we have back of a CPI. You can divide back by CPI because it's equivalent to. Scaling the remaining work by CPI. I'm not explaining that properly. BAC is comprised of AC plus this. Um. The costs spent so far and the cost of the remaining work. You can scale that. By. You can scale it back. Well, you know what? It's an exercise for the reader. But if you basically algebraically reduce this, you can't get to this term. But if you replace that by CPI, you can get to a to a version of this with CPI as the second term, it just falls out of the maths rather than me try and explain it in a bad way in a lecture. I'll leave that as an exercise for you, but I think it's worth doing because that came up on a previous exam paper. Okay, good. So today, what are we going to do? We're going to learn on a high level some three very basic ways of managing software projects. We're going to talk about lean. We're going to talk about waterfall, which I presume you are very familiar with. And we're going to talk about agile, which I think is usually quite popular amongst computer science students. So we're going to talk through these three different methodologies or three different approaches to developing software, and get a bit of a flavour for each one. We're going to talk in a lot more detail about that next week, but we're going to have a guest lecturer who's going to tell us about some of these things in real life, in real software development environments. So you might get a flavour of similar to how we have prints to in theory. Then in practice, this is kind of these concepts in theory followed by these concepts in practice. So hopefully you'll enjoy that. I've got a picture of a burger on there. I guess I'll explain that soon. I guess maybe there's a link here. We're talking about meat. When we think about lean, the kind of words that we think of are having no superfluous fat, right? Nothing in excess, nothing wasteful. Everything is the good quality stuff. Everything is what we want. No wastage. And that really is the fundamental principle of lean. Whether it's lean manufacturing, lean software development, lean thinking, lean is a philosophy that underpins a lot of ideologies and philosophies that people have, and it's something that we'll learn about today as being an important part of software development, too. So it's about having no excess. So where does lean come from? Well, let's think back to the sort of the dawn of the 1900s when car manufacturer was was big, especially in the local area in Coventry. Companies like Ford. They had an ingenious system of manufacturing cars in an affordable way. Prior to for this point in time, it was very difficult to manufacture something so complex as a car and sell it affordably to the mass market. What Ford realised was mass production is a way of achieving that efficiency. In contrast, over in Japan, Toyota realised that, well, we haven't got the resources or the money up front to do mass production. So what they came up with was very efficient practices within the production line to achieve efficiency in a different way. So what Ford said was, what we're going to do is we're going to build the perfect product. So they figured out exactly what that product was. They figured out ways to remove costs from the manufacturing process, to do things. By doing things at large scale, they had large batches. They produced 1000 exhaust pipes. They produce a million lamp headlamps. They did it on scale because that was more efficient use of time and resource. So they made money by doing efficiency, by scaling up for efficiency. Whereas the Japanese approach, the Toyota approach was to seek perfection by maximising value to the customer, not giving them anything more than they needed, giving them the the very essence of what they wanted and nothing, nothing excessive. They removed any waste from the manufacturing process. That meant moving certain facilities closer together to minimise time in between movement of one place to another. Everything was done in small batches, not big batches, and they focussed instead of efficiency of scale on efficiency of pipeline, the efficiency of flow. So two different philosophies based on the fact that in America where Ford were developing land was not an issue, storage was not an issue, materials and parts were not an issue. What was expensive was labour in Japan. Alternatively, there was there was very little space to build and manufacture and store a million exhaust pipes. They had to find efficient ways to do things. And this is post-war. Japan were financially much weaker than the Americans. So. That's where it started. Now, of course, Ford famously, Henry Ford famously said, you can have any colour car you want as long as it's black. The reason he said that was because their their economy of scale, manufacturing process was very efficient and cost effective, but not flexible. It was only able to deliver this perfect product that they'd figured out. Whereas the Japanese, the Toyota model, was very dynamic with its small batches, it was able to adapt its product to specific cases. Think of a more recent example when electric cars became popular when they introduced the emission zone in London, Toyota were the first to get the Prius onto the streets, and they dominated the market for a long time before other manufacturers came along. Because they were able to very quickly adapt. They just swapped out the engine component for a motor component. Very simple. Well, not that simple really. But along those lines, they found an efficient way of adapting their fleet, which mass production manufacturers couldn't do. Okay, so Toyota back in the day had lots of principles of lean manufacturing. And in 2001 they published a document stating that these is what they were. So I've included this icon here because we're going to talk about lots of different philosophies of lean, which all really kind of linked together. But this particular, this particular set of seven are the lean manufacturing principles, which is why I've got a picture of a manufacturing plant in the corner. So that's just to kind of give some context to you. So the seven principles were things like eliminate waste, amplify learning, deferring commitment, do things at the last minute, delivering fast, empowering the team, building integrity and making sure it's a quality product and seeing the big picture, seeing the whole. So these are the philosophy, philosophical principles of lean manufacturing that Toyota embedded in their practices back in the early 1900s and throughout the century. So we're going to come back to them soon. So first of all. And the big one eliminating waste. There are three Japanese terms that you'll need to learn. You'll need to learn a bit of Japanese in this module. There's Muri, Muda and Mura. Okay, these are three words Muri. This is overburden. Apologies if my Japanese pronunciation is terrible. Murray means overburden. This is the waste that comes from doing things excessively. By putting too much work on your staff, by being unreasonable in terms of your demands of time and effort. People can't work at an unsustainable pace, so you need to give them a reasonable amount of work to do. Machines also can't work night and day. They need some time to be maintained, to be, to be fixed and things like that. So overburdening things is not an efficient practice. In the end, things will break and you'll have an outage. And that's not efficient either. So overburden should be avoided. Muri must be avoided. Another waste is mud. This is just a waste of doing stuff that's pointless. Building things that people didn't want. Building features that you like but weren't asked for by the customer. Anything that consumes any kind of resource without creating immediate value for the customer is perhaps excessive. It's wasteful. So minimising those things would be useful. Why is the exhaust pipe this long? The customer didn't need it that long. Can we make it shorter? Things like that. And the third waste identified is Mura unevenness. This is the idea of that irregularity creates inefficiency. Inequality creates inefficiency when things aren't steady, when there isn't a steady flow. So for example, working really hard in the run up to a deadline and then do nothing for weeks and weeks before the deadline, that's inefficient. It's inefficient use of your time. You're going to be wasting time not doing anything productive for a long time, and then you're going to burn out. You're going to work too hard. You're not going to be able to work as effectively in that kind of environment. So that is inefficient. Having an even schedule, having, you know, three exams in a row and then two weeks with no exams, it's it's inefficient because it's not making the best use of the resource available. So having variability is a bad thing. So how do you remember which ones which I came up with this little trick here. But I don't know if it's the right one. Moody carry. They kind of sounds similar to about carrying a burden. Moody has a duff. Duff, you know, something useless. And Mura is kind of ragged. It's kind of the unevenness exemplified. You can make up your own. That's fine. I just thought this is. That's how I remember which one is which. I'm not fluent Japanese, so I need to sort of do that. So another way of thinking about these things is through this this diagram here. So this truck here is overburdened. At some point these wheels are going to break, the trucks going to break down. You're going to have an outage later on. So this may be considered an inefficient scenario to overburden this one. This one truck or this one driver. All right. This time there's fluctuation. This truck's going to wear out before this truck. It's not making maximum use of the load of the availability. This system here, the trucks aren't fully utilised. There's waste here. There's waste in terms of having too many drivers. There's waste in terms of, you know, time and effort there. Whereas the optimum might be to load your trucks in this way. So let's, let's do a little bit of a quiz and see if you understand which waste is which and why. So we'll start with the first one here commuting to the office. Which kind of waste is that. Is it a muri, a muda or a mura? So I've written underneath what it means unevenness. This is just kind of general waste. And this is overburdened here. So this bin is overfull. This bin has a full waste of waste paper section and two empty other sections, as is common in those kind of bins. If you've ever had one of those. So yes, get your answers in commuting to the office. Why is it wasteful? Okay, I'll stop the poll there. Unless you're very productive on your way to the office. Mood is. Mood is the answer here. And then I can animate that into the bin. Hi tech special effects there. Okay. Next one. Mass production for economies of scale. So this is the Ford model, right? The idea that we're going to make really efficient manufacturing processes by scaling up. Why is that not lean. Why is that wasteful. Okay, I'll stop the poll there. The problem, of course, is that it creates unevenness. You're doing large batches. Large batches are not flexible. They're not. You can't smooth out the load and adapt to changes. So there's an unevenness problem there okay. Moving between lecture theatres students have to move between lecture theatres. The lecturers. Don't. Why is that? Why don't the lecturers move to see to where you are? You should stay still. The lecturers should come to you, right? That's more efficient. Okay. I think most of you got your answer in there. So there we go. Yes. Another way. It's another pointless thing. There's no need to be sitting at home connecting online. Well done to the lean thinkers there at home. You win. You win today. Okay, doing an all nighter to meet the deadline. So it might feel very last minute, which is a kind of a lean principle, but I'm afraid it isn't lean. It's wasteful. And why is it? Why is it so? Okay, good. You get anything nice and fast here. This is good. Doing an all nighter is, of course. Overburdening. You're overburdening yourself, and that short term it means you can't work as effectively during that period of time now. Of course they may. Let's hear it. Yeah. Yeah, because. Because your unevenness in your workload has created an overburdened hasn't it? Of your of your person. But yeah, certainly it fits into both. But I think the reason, the reason it's wasteful is because of the overburden. You may be able to be very productive when you're not working hard in that in those last minutes, but that all nighter is really overburdening you. Okay, next, occasional defects occurring in production. Why is that wasteful? Oh, I should say, which kind of waste is that? Should be. Obviously it's wasteful. So yeah that's a that's hopefully a nice easy one. So I'll stop that one. That is of course in the middle, but again, just completely pointless to make defective products. That's why integrity built in is an important aspect of lean. And finally zero hours contracts. What is wrong with zero hours contracts? Now this is an interesting one because zero hours contracts were were invented because they created flexibility. They enable flexibility for the worker. They enable flexibility for the employer. That's surely a lean thing, right? Okay, so let's get your answer in. Okay, so the answer is. Unevenness. So. I thought I'd written some notes on my slide about this, but obviously I didn't. Does anyone want to venture as to why Xero's contracts are inefficient due to the unevenness? Yeah. Yeah, exactly. So it creates an evenness from the point of view of the employee that they may not be making efficient use of their time. Absolutely. On the other hand, some people might find it enables greater efficiency. But not having that reliable income up front makes it very, very tricky for them. Okay. Oops. What's going on? Sorry. I've lost the focus. Let's go back. Okay, let's check the leaderboard. Here we go. So some people getting on five out of eight there. Well done to to Boris and Oliver. Hopefully you can find yourself on the list there. All right. So eliminating waste then. It's important in lean. And these are the kind of wastes that Toyota identified back in 1943. One waste is transport moving things from one place to another. There's no point doing it any more than is necessary to meet customer demand. So minimising transport is really valuable. Um, inventory, storing stuff in warehouses until they're needed. Materials, products, resources. There's no need storing them any more than is necessary. So minimising inventory is more efficient, more efficient in terms of your rental costs and other things like that. That's how you reduce costs there. Motion, moving things between process steps, minimising that. So obviously you're transporting them as well. But that idea that you've got to move things from one machine to the next, why not move the machine. You know, other ways to minimise motion. Waiting around, waiting for the product. Waiting for people. Waiting for machines to be ready. Very, very hard to minimise waiting. But it's inevitable. But if you can find ways to efficient to improve the efficiency of your production line to minimise that, all the better. Too much processing, more processing than is then is then is demanded overproduction, making more products than the customer needs. Having defects, issues in quality and passing them down the supply chain, only for them to come back again later saying this product didn't work. After going through all those steps and manufacturing it, it didn't work. Throw it away. And the eighth one skills. This was actually added a lot after 1940 18. Sorry 1943. This is added probably more recently, but not seeking out the right expertise and creativity of your own people. So it's a waste of opportunity to not have your team involved in technical decision making. Having hierarchical structures is inefficient. Now, I think Toyota culture and Japanese culture was perhaps very hierarchical for a long time, and that's why this one came in a bit later. But yeah, it's it's an important thing, right, to have everyone involved in decision making. So let's look at which of the manufacturing principles we already talked about. We've dealt with. So we've dealt with eliminating waste the mood at Murray and Moura. We've talked a bit about deferring commitment by lowering inventory. We've talked about speed of delivery by reducing transport waiting. Talk about empowering the team through utilising their skills, in particular building integrity. We don't want we don't want defects. So we've dealt with some of these things. Now there are other ways of thinking about it too. So how do you embody lean? What are the what are the practices that we employ to be lean? Well, let's first of all talk about this concept of pull. Pull is the idea that you make what's needed only when it's needed. You just make the stuff you need. You don't do anything excessive. Now, this is a push system. You just make tons of stuff. This is inefficient. This is overburdening this worker. It's unstable. Probably more than more than is needed. There may be economies of scale on the push side, but ultimately it's not the most effective or efficient approach. So we got three burdens here. The overburden of this person working harder than needed, the unevenness of inventory, having to store this stuff, or overproduction and the uselessness. Because if demand were to change and we didn't need this product anymore or these parts anymore, then it was for nothing. We had to throw them away. Talking about burgers already. McDonald's and other fast food restaurants are very good at efficient production of burgers. They get the right number. At the end of the day, there are almost 2 or 3 left of any product. If that going to waste just enough to feed the staff on their way home, very little waste. And they achieved that using a clever thing called a regulator. This thing here is an ingenious device. It's a physical device where you put burgers into slots. When a burger is removed, it reduces the number of burgers in that slot. And when the number goes down past a certain threshold, the kitchen realises you've got to make some more burgers. That's how the communication happens. No human communication, because people are employed to work. And McDonald's may not have those skills, but they are able to spot when the is empty. I think probably they have a light as well, just in case they didn't spot it. I think a light comes on when the weight drops below a certain point in that regulator slot, so they know to make more chicken McNuggets or whatever. It happens to be very, very efficient system. So you've got person in the kitchen doesn't have to speak to the person at the tills, they're just dealing with the customer. And the burger regulator provides the communication that is called Kanban. The idea of a visual signal that tells somebody what they need to do. Important things about Kanban is the order comes in from the customer. This is the where the demand comes from. The burgers are removing the regulator. There are plenty of on demand just in time. This is the lean philosophy here. Not made to a forecast. They don't say. How many customers do you get on a Friday night? Usually 38. Okay, let's make 38 burgers. That's not how it works. You make just three and then wait until the customers come. It means the food's always fresh. It means the food is always quick and ready. But there's never anything hanging around for long. The signal comes from this direction, the customer sends a signal via the via this operator here to say what they want. The burger regulator sends a signal to the kitchen to make more food. This is a pool system. There is no pushing. There is no making things to a forecast. It's all about acting on demand. That's the key. So the food flows this way. The signal flows back. That's a very important point about Kanban systems okay. How does this apply to software development? Of course. Why am I teaching you about burgers. Well, exactly the same idea can be done in software development. Instead of being burger makers in the kitchen, they're programmers and the features are the thing that are determined by. So ultimately by the customer. Right. So the customer sends a signal by saying, I want these features. The person doesn't develop the feature until the tester has tested the previous feature. Otherwise, the developers are working ahead of time. We're going to come back to talk more a bit about the Kanban software workflow later, because I think this is a bit counterintuitive to think that the signal goes from a customer to the tester, back to the programmer. That feels backwards. We're used to writing software in this way. We do our programming. We do our testing, we give it to the customer. This is a completely complete inversion of the way you might think of software development being, and I think that's it takes a conceptual shift to move into the Kanban lean way of thinking. So I appreciate this might not make immediate sense to you right now, but I'm telling you now, the signal flows this way in a pool system. So we'll talk more about that later. But work is done taken from the regulator for testing. So the work is going this way right. The work is done on demand, just in time by the programmers, and it's not made to a requirements document. This is not waterfall, right? And it's not pushed at the customer saying this is what you wanted. The customer is consulted. These are really important ideas within within Kanban. So how does Kanban tick off some of our lean manufacturing principles? Well, the idea of doing things just in time is all about deferring commitment. That's good. When I said don't do things at the last minute, well, actually do things at the last minute. It's a good idea. Just in time is a really good idea. Don't overburden yourself, of course, with all nighters. But certainly just in time is better. There's no point doing your coursework at the beginning of term before you've learnt the material, right? You want to do it close to the deadline. Delivering fast, getting those burgers to people quickly that maximises the flow of value to the customer. And that's the whole point of this, right? You want to give your customer what they want. That's how you're going to make money out of them. Okay. So that's two of the lean ideas. Now we're going to talk about a third thing, which I'm sure you're all fully aware of a minimum viable product. What's that? Minimum means no more than necessary right. The minimum the least. No waste, low cost, fast delivery. Just the bare minimum. The essentials. But it's also viable, right? It's valuable, it's useful, it's beneficial. And it's a product. It's something they can actually use. So it's focussed on a customer. That's what a minimum viable product is. And as you can see, it maximises the flow of value to the customer. Because that's that's by design how it's been made. Right. And that's why it's lean. So this illustration I think explains minimum viable product better than I can. Instead of building your vehicles in Henry Ford's method, you deliver something very minimal to your customer and get that feedback straight away. This person had to wait a long, long time before they got their car and they got the car as per the original design. But maybe it's not the perfect thing. Maybe some customers will be happy with just a skateboard, and other customers will be happy with the bike. And some customers. Maybe they didn't need four wheels. And in the end, the final design is different to the the requirements document. Push version right doesn't have a roof. Why did you make a roof? We didn't need one. We live in a hot country. There we go. That was. That was what was ultimately wanted. The customer is even happier and you did less. That's the philosophy of minimum viable product and lean. Okay. So now we've talked about the idea that we're going to deliver fast again, and we're going to amplify learning. We're going to have iterations, right. We're going to get feedback from the customer and deliver value to them, not value based on our forecast. Okay. So I've rattled through that quite quickly. But hopefully that gives you an idea of what Lean's about. Now let's talk a bit about waterfall. Waterfall is obviously, as you know, it's a cascade of water falling from a height. There is very much a flow from one level to the next. The water doesn't go back up again, just keeps on flowing down. Interesting quote about Ruth kayaking there, right? Now I want to provide some context when I'm talking about waterfall. Now this is a computer from before I was born, 1977. This is a this is a pretty high tech computer. It can do some good stuff as well. This is what it can do. I hope you can do it. Oh, it's not gonna work. Is. I'm very sorry to not be able to show you the kind of graphics it can produce. I'm going to show you on this side, this is what it's supposed to look like. This is the kind of graphics you can get from this machine. Very cool stuff. I'm very sorry I can't show you the video because it's quite a good one. Well, that was 1977. Anyway, the graphics were very poor. Unfortunately it was. It was not a good time for for the world of software engineering because computers had just been invented. Right. It was, you know, this is when like Star Wars was, was out. I mean, this is like before, you know, good special effects and all sorts, right? Now, this paper here. By, I think, Charles Royce or William Royce, whoever it was. 1970 Royce coined this paper, coined this idea of waterfall in 1977, years before we really had even computers to do really basic stuff. And so the point is, this idea of waterfall was invented before computers really existed in any meaningful way, before software engineering was a practice that we did. I think used punch cards and things like that to write programs. Right. And what you said was. So he described it as a system where you have system requirements, you establish what you're going to build, you turn those into the software requirements, you do some analysis. So this is kind of the the requirements analysis. Then you design your program, then you do some coding and then finally do some testing and then make sure it sort of works properly and it gets implemented and delivered to the customer. Now when he introduced this back in 1970, what he said was it's rubbish, shouldn't do this. So actually he wasn't saying do waterfall, he was just explaining. This is a logical way of describing how programs could be developed, but it's a bad one. Now of course there are pros to it. It's repeatable, low management overhead. It's very clear about the expectations. You can have explicit requirements gathering and know exactly what you're meant to be doing. Everyone knows what their job is. You're either a tester or a requirements engineer, or you're a designer. So it's simple, right? But that's not a reason to use it. It's very high risk. What it means is you detect very late when something's gone wrong. You detect in testing that your design was bad. You're going to go all the way back to the design phase, or even worse, that your requirements are wrong. Go all the way back to your requirements phase. So if you think of it in a sort of a project management way, it's one long critical path. We can't plan and analyse that well. We know that it's very hard to do effective planning because you don't really know what you want to build until you start building something. It requires a lot of documentation between each stage to work, even at all, and it does not support change. And this was all identified back in 1970. So Winston Royce, that was his name. Winston back then first described this method, saying the implementation described above in figure one is risky and invites failure. Fail. Fail to satisfy various external constraints. Invariably, there's a major redesign required. It's so disruptive that the software requirements, which provide a rationale for everything, are violated. In effect, the development process is returned to origin, and one can expect a 100% overrun in schedule and costs. So the inventor of waterfall said, don't use it in 1970 yet we're still using it today. Bazaar. In fact, William Royce said, what you really need is kind of cycles between each different stage. So you can go back and check. And you need some extra big cycles to do this as well. And actually, this is the final version he came up with in that paper in 1970, which I think is pretty horrific, actually. I'll talk through it very quickly. You have a design review stage. You have a documentation aspect to the design. You do waterfall twice. You do a mini version of waterfall at the start during the preliminary design before you go into the real full waterfall. So there's kind of an iterative component there. You have testing. All the way through. Like this. You involve the customer at different stages. Now, I'm not saying you should use Winston Royce's 1970 idea of how software should be developed. It's probably better than waterfall, but it's probably not that good either. But nobody. The point I'm making here is nobody ever thought naive. Waterfall was a good model, not even its creator. People call it traditional software development, but actually it was invented before computing really had any traditions, and certainly was never advocated by its creator as something you should do. But still widely used and simple to understand, and something that is used in the real world even today. And you might end up finding yourself doing a waterfall project in the real world when you leave university. Be aware of its risks. Be aware of it if its challenges, but I don't recommend it. So that was waterfall. So third and finally then today we're going to talk about agile. Now. Agile is a bit of a paradigm shift on waterfall, and that's why I guess it's useful to know what waterfall is. So the concept of agile is about being nimble. Being acrobatic, I suppose it's about being able to move and change and adapt quickly, ultimately being able to change. And that's really why the word agile is used, because change is central to agile. So the traditional approach, which as we already established, isn't really traditional at all. A customer requests something. A product owner or somebody within the organisation defines what that is. They're the technical, the technical version of the customer. The development team then makes it to those requirements and then finally the user uses it. And I've done a big fat blue arrow here because the user has to wait for the big fat blue product to arrive at the end. This is very slow. They get they get everything all in one go. Now, of course, it would make a lot more sense to give them all, give them little bits at a time. This is a bit like the idea of the minimum viable product. You give them a little increments. So obviously we can draw that like that. We've got an iterative loop. And the reason the loop does this is because the the end user is in that loop. You know, in fact, the customer should probably also be in that loop. But I suppose the product owner is representing them. From a technical point of view, it might not be always possible to get the customer directly in that loop, but that's the key idea. Two things iterations and customer in the loop. If you said for your third year project that you're doing agile and you haven't got a customer in your loop, or if you haven't done iterations, then it's not agile. You need both of those things. So how is this? How is this different then to the traditional method? To the waterfall method? Remember in traditional it was planned driven. In agile, it's value driven. You choose what you develop based on the value to the customer. You prioritise things. As opposed to planning upfront what you're going to make. Okay rather than fixing the scope. Rather than saying this is what we're going to build and saying it's going to cost you this much and it's going to take that long. Instead you say, how much money have you got? How much time have you got? We're just going to keep on going until we're done, until we run out of time and money. So all of a sudden you went from fixed scope to really variable scope. And that's the that's the that's the trade-off you have to make when you switch to agile. You no longer get what you asked for upfront. You might get the exact budget and the time timeline you asked for, but you will not get the features you ask for. You will get the features that you need, not the features that you wanted upfront. That's the big paradigm shift I think that you need to be aware of. In waterfall. You solve everything in one go. You do one big final delivery. In agile, of course, you're solving iteratively. In traditional the progress is binary. In agile, project progress is gradual. In traditional cost, time and quality at risk in agile scope is at risk. The others can be fixed. Okay, so there is a risk. Agile is not a magical solution. It's taking. It's just reprioritizing your objectives. It's throwing the iron triangle. Away, or at least two of its dimensions away and focusing on on making scope the thing it takes a risk with. And of course, rather than be risky till the end, the risk declines with progress with each iteration. So this is a slide I found online. I don't really know what it means, but the idea is that you're turning waterfall on its head. I guess what it's saying is you're changing the iron triangle. You're reprioritizing the iron triangle to focus on scope. So the waterfall method was of course having fixed scope, fixed requirement document, and then estimating cost and time. As opposed to fixing the cost and time and estimating the scope. I'm not sure why it needed a diagram to explain that, but there we are. You might like you might like this illustration of what it's done. I think conceptually I like the idea that it's it's changing the way we view project management. So if you're doing agile. You probably have heard of the Agile Manifesto. The actual manifesto is this idea that was that back in 2001, a whole load of brilliant software engineers and big names at the time went out a chat, went out a meeting, and they figured out that what they really wanted software developed to look like was very different to the way it was being done. It was probably being done in a quite traditional bureaucratic way, and they wanted it to be done in a different way. So what what they realised was they valued some things more than others, and they kind of inverted the balance here. So they said we prefer or we value individuals and interactions over processes and tools. That's not to say they don't value processes and tools, but they value individuals interactions more. They value working software over comprehensive documentation rather than writing about it. They want to see it working. Documentation is still useful, right? But working software is an even better way of demonstrating that something works. Customer collaboration is more important than negotiating a contract up front. So rather than agreeing exactly what you're going to do, instead have a customer as part of that loop, as part of that team. And finally, responding to change is more important than following a plan. So there's value in the items on the left, but sorry, there's value in the end on the right, but the ones on the left are valued more. Okay. These ones in bold are more important if ever there's a trade-off to be made. Favour the ones on the left. Okay. So that's a really important idea. And what that ends up becoming is a set of principles. The principles being early in continuous delivery of valuable software. Embracing changing requirements even later on in the project. Delivering working software frequently, e.g. every two weeks. We call those sprints. People working together daily, the business people and the developers working together. Motivating your team, empowering your team by supporting them, by trusting them rather than telling them what to do. Having face to face conversations. Having working software. As a measure of progress rather than reports. Working in a sustainable way, making sure that people aren't overburdened. Focusing on excellence. Quality matters. Focusing on simplicity. So simplicity. I like this one. The the art of maximising the amount of work not done right. You want to do the minimum necessary to deliver value. So that's again quite a lean idea bleeding into the agile idea. Self-organising teams. Letting teams figure it out for themselves, how they're going to be led and managed, and reflection. Self improvement. So. This pie chart is a recent ish view. Hasn't changed that much in about ten years, of which agile methods are currently dominating in industry. So 58% of organisations using agile do so using scrum. Scrum ban is popular. Kanban is popular. Extreme programming always hovers around 1%. I when I updated the slide recently, it went from 2015 to 2020. The numbers are very, very similar. So this is kind of what he's done in the industry. So if you go into industry you're probably going to do scrum or some variant of scrum. Okay, so let's talk about scrum. So scrum is based on this idea of a user story. A user story is just a simple sentence that captures all of the important stuff that we talked about in our Smart Objectives lectures previously. In a way that's kind of doesn't sound very project management, so it's really appealing to software developers. A user story looks like this. As a type of user, I want some goals, so that's some reason. You can see in there we've encoded the who, the why and sorry, the who, the what and the why all encoded there within that tomato. Sorry not smart objective in that user story. Okay. Here's some examples of user stories. As an authorised user I want to create a new account. It really tells you what feature you want to make. But actually it doesn't tell you how you're going to make it. So it's not constraining the developers on how they achieve that that goal. Right. So it's focusing, as we talked about with objectives on what we need to do, what we want to achieve, I should say. But it didn't tell us how we're going to go about doing it. So the developers can decide on the best method to solve that purpose.

SPEAKER 3
And.

SPEAKER 2
You can group these together. So a group of these is a group of user stories. In epic. You've got themes which is kind of the top level project, top level objective of the whole project. So what this user story captures of course, is scope. It's the requirements the who, what, why and not the how. Okay. Now what we can also do is we can add things like priority, estimated workload or effort. A definition of done. Are you what defines this as having been completed. So this allows us to sort of prioritise and figure out which of these user stories we're going to focus on in the next sprint. You probably want to group them together and say, right, we're going to focus on achieving this this week or this fortnight, and that's how we're going to do it. So it's really everything is based around this backlog of user stories. It's really important. Now in scrum there are some there are some roles. But these roles are quite flexible. Right. We're talking about self-organized teams here. This is agile. So the person in charge of representing the customer is someone called a product owner. So they have to somehow capture the the customer's vision. Right. And they communicate that via the user stories to the team. It's their job to prioritise and figure out what's going to go into the sprint, because they're the one who has the conversation with the customer to figure out what's the priority, what maximises value. And they're the one who will decide at the end of each sprint whether to accept or reject the work that's been done. They also have to secure the funding. They deal with that stuff. So they're kind of the business side of scrum. The team themselves. The development team is usually between 3 and 9 people. If you need more than nine people, it's best to split into two sub teams. It's not a good idea to have 1015 people all working on the same sprint just becomes a mess. Things start going wrong. It's good to modularise modularise and try and separate them out. So no more than nine is recommended. And that is a cross-functional team. So developers, testers, designers, all those skills together so that when you have conversations you can really make good productive progress. One person within that team is not their manager. They are just called the Scrum Master. Okay, you could even rotate that person. They are not kind of superior to anyone else. They don't tell anyone else what to do. They are meant to be a servant leader. It's their job to make it possible for the team to get on with the work. So they remove impediments, they help everyone. So they work across different teams as well to improve communication. So their job is to kind of bind everything together. They're kind of the glue the helpers and they host me, host meetings. There are three meetings. There's a sprint planning meeting, there's the daily scrum and there's a retrospective. So there's sprint planning meetings at the start where you figure out which user story you're going to focus on. In the sprint, there's the Daily Scrum, where you figure out how everyone's getting on and figure out what the blockers are so that the Scrum master can fix them. And there's the retrospective at the end where you reflect on what could be done better. And scrum embodies these values. Commitment. Everyone is committed to the goals in the sprint. You've got a team that's that's bonded together that has that kind of common goal. People need to be allowed to be courageous to do what they think is right. These are some very noble. But what that ultimately means in practice is that people feel like they can say, oh, I don't know, that's a good idea and not be like, what do you mean, right? No one's going to be offended if people talk openly about what their opinions are. So everyone has should be empowered to be be courageous. So there's a lot of trust and openness needed to build a team like this. Not all teams work this way. It's not easy to get a team where people can freely speak about what their opinions are. You know, how often would you put your hand up and tell your boss, I don't like your idea? I think we should do it this way. You know it can be difficult. Focus. Everyone should be focussed on the current sprint. That's why sprints are short and there are small number of work items to do. This openness that I've already mentioned. People should be open about what problems they've got. I messed up, sorry. Here are some doughnuts. You know, it's it's a cultural thing. You need to change a culture to have these scrum values. And ultimately, I think respect. Right. You've got to trust people. You've got to respect them and you've got to let them do their job. You've got to trust that they're going to do their best. And if you can create a culture that embodies these values, then you've got the right ingredients for a scrum team. If you can't embody these values, then scrum is not the right choice for you. So scrum starts here. As I said with a product backlog, this is a whole list, a whole load of user stories, all the possible features you could possibly ever imagine that the customer has said. Um, and everything is centred around this sprint, this two week or 1 to 4 weeks, according to this typically two weeks sprint. The input to the sprint is a sprint backlog. These are the tasks plucked from the backlog pulled from the backlog. Let's say nobody said these are the ones you have to do. The team can have a conversation during this meeting to figure out which ones they want to prioritise based on the customer's requirements, based on their own technical expertise and knowledge. So it's kind of like a pool system rather than a push system. So the sprint backlog identifies what we can do in two weeks. Everyone agrees. Can we do this in two weeks? Yes. No, it's too hard. We can't do this because we can't do that part. Okay, let's change it. Everyone comes to a consensus, so everyone's focussed on the prize. Then during those two weeks. Every day there is a daily scrum. This is the sort of daily meeting where everybody has a conversation about how things are going. You might look at the something like a burndown chart to see if the progress is going to plan to see if you're going to finish everything on time. Otherwise, you might need to reprioritize. You might a product backlog refinement. You might change. Change them. You might add some new ideas to the product backlog based on something you've discovered. At the end of the two weeks, you should have a potentially shippable increment working software delivered every fortnight. And that's where you might have a review, where you review you. You might demonstrate the software to the customer. And you'll also have a retrospective where you will. Think about how you can improve future sprints as a team. So the retrospective is like an internal reflective review. The review is the outward facing customer facing thing where you show them a demo. Okay. Now the various artefacts we talked about when we talk about Prince. We talked about all the documentation. There are some artefacts in scrum as well. So the user story that's the smallest unit of of work. Tasks maybe related to user stories. Maybe dealing with a bug or something isn't directly related to the user story, but maybe helps facilitate or support it. We talked about the product backlog already and the sprint backlog product increment, not piece of software and certain extension documents like a burndown chart, which we'll talk about in a second, where you can measure velocity, which is the speed of the team making progress. This is what burndown chart looks like. As you tick off items, the number of remaining items will go down. What you're hoping is that the number of remaining items in the backlog go down at a reasonably steady pace. If this is kind of behind schedule, then it's not going down quickly enough. What tends to happen is these things kind of have a bulge at the start and then a big speed up towards the end, because perhaps you haven't prioritised certain things correctly, or some tasks take longer to get up and running before you start taking them off. You could probably, if this starts to happen, regularly, shrink your tasks down into smaller units so you can make more visible progress sooner. That's the idea of a burndown chart. Rather simple. So finally, the daily stand up meeting. So in the daily stand up meeting, all up to nine members of the scrum team will stand up. And this is something I have personal experience of, of doing in a software environment. And it's pretty awful actually. So you all have to meet like this, including people who are very, very senior to you because you're all on the same team with no kind of no roles. And what each person has to do is say what they did today or what they did yesterday, what they're going to do today and what's blocking them, what the issues they've got. And if the culture is not right, it's very, very difficult to speak openly about these things. Yesterday I kind of was hung over and I bunked off. Sorry. You know, you don't want to admit that to the person who's employed you, right? So that's not so great. You feel under pressure and there's not. And that openness breaks down very quickly. And you go round one after the other. Right. When Sally speaking right now, how does Dave feel? Anyone want to venture? How he feels? Sally's telling. Did you find anything? It's pretty. It's minds wandering. Not not listening. His mind is wandering. Maybe he's not listening. Do you think anyone else. How do you think he thinks? Yeah. Bored? Yeah. Bored? Possibly. Yeah. Yeah, yeah, I think he probably is thinking, what am I going to say? I haven't done anything yesterday. So when that was me, maybe we were all different, right? But when that was me, I was feeling pretty stressed, right? One of the suggestions there not listening, perhaps thinking what he's going to say. Thinking about how he's going to impress his colleagues. He wants to say something really good. He wants to tell them something impressive. Right? He wants to avoid embarrassment by saying the wrong thing, especially if he's new. So I think he's probably feeling a bit stressed, actually, and he's certainly not listening. Anyway, to Sally, that's that's the bottom line, really. How does Bob feel? I think that definitely comes down back to what you said. He's definitely bored, right? He said his bit. He's done his thing. He's had the adrenaline surge of speaking and now he's thinking, yeah, come on. It must be lunchtime now. So no one's listening. No one's listening. And this is pointless. It's a two hour waste of everyone's day. Okay. I think a better, a better way of doing this is to perhaps have some kind of progress board. Something like this. Task one block. Task two is in progress. Task three is not started. And now, instead of talking about what you've done, someone says, oh, who's working on task one? And Bob says, oh, that's me. And then he can talk about it. And there's no kind of immediate. So you become focussed on tasks, and there might be more than one person working on that task, and it becomes less about you and what you're saying and more about a conversation. So moving this away from the individual and towards the task, I think is a better, a better way of doing it. Okay. It's kind of more asynchronous and actually a better way of doing this. You just have a Kanban board, right? Just put the work on a board which tasks you know, which, which have been done, which have been doing, which is to do. You don't need to have any conversations at all. You just turn up and say, right, any blockers? What's wrong? And someone will say, well, I can't do can't pick this item from the to do list because someone's waiting for the testers to finish doing what they're doing. You know that is much easier, much less focus on the individual, much more focussed, focussed on the tasks. So Kanban is essentially a good solution to the daily Stand-Up in Scrum and Scrum. Ban has become a very popular variant of scrum for that reason, which combines the Kanban board benefits of visible planning with with scrums, iterative loops. Okay. And of course we already talked about this earlier and we talked about the burger regulators. So you can kind of see how software development can be a bit like McDonald's. I don't expect you to have made that conceptual shift fully yet. And we will talk about more more about that in the seminars and also next week. Okay. But summarise today, then we have talked about lean. We've talked about the idea of eliminating waste and we all practised our Japanese. Hopefully you'll you'll be now fluent. In particular, an important concept was pull versus push. It seems simple, but actually it's very difficult to do pull in reality, especially if you want someone to do some work. You know, you've got to somehow let go of that desire and start to enable pull. And it's a cultural shift, and it's a difficult one to get right. Building a minimum viable product is a really good way to be lean, and Kanban is obviously a fundamental, lean idea. We also talked about agile and a paradigm shift over the traditional Winston Royce approach, focusing on flexible scope, continuous delivery, collaboration and trust, scrum being a good example of that, and Kanban also being very useful component again of that. So lean and agile are kind of complementary ideas. They're not two different approaches, but actually you can use bits of each when you're choosing a methodology. So after the break, in about five minutes, we're going to have our guest lecturer, John, who's just arrived perfectly on time, telling us about all this stuff I've been talking about in real life. So he'll just he'll debunk all my myths and tell you that my theory is all nonsense. With any luck. Before we do that, let me check if there are any questions in the Q&A. If I can. Nope I can't.

SPEAKER 3
Okay.

SPEAKER 2
Brilliant. Yet? So you've learnt some Japanese. I'll take that one off. If I'm being asked to state the difference between Muhammad and Murray, I will report that I get the wrong exam. Yeah. Fair enough. Yeah. Good. So. Well, don't forget in the homework. Answer that person. You're liking the lecture. Speed. Good. I did have to go fast, because I did a two hour lecture in one hour so that we can get our guest in there. Hopefully you appreciate the speed the terms will be using the exam, but with an explanation of what they mean. I think why is mass production mura mass production is Mura because it's about creating large batches and small batches creates more steady, even flow. Okay, we'll talk more about that next week. When we talk about developing an effective Kanban flow is the guest lecturer examiner. All the guest lecturer itself is not examiner able, but there are lots of important concepts and ideas that you'll learn about, which you will probably want to consolidate into your understanding of these concepts. It will be beneficial for your essay and also probably beneficial for your answering questions in the exam as well, although the content itself is not explicitly examiner able. Okay, so I will see you back here at seven minutes past. So see you soon. Thank you. I don't even see you. Let's get you set up. Hopefully five minutes is the right time. I remember the last time that I didn't give you much time. So I'm conscious that I'm going to go on. Your pace was described as outrageous. I'll see if I can beat that. Yes, yes. It's always good to have a target. Absolutely, yes. Do you need a special kind of dongle, or are you? I have a USB. If that's what you've got. I've got an adaptor with. We've got an adaptor built into this HDMI, two USB, c. I might just plug a paranoia power supply as well. It doesn't. Hello? Hey. I just want to check for, like, one of the. Yes. So, like, you know, the group come out with, like, smart objectives. If I make them more smart. Is it like it's like this is like. Yes, it is. Absolutely. It's absolutely okay. Yeah. Of course you can do that. And you can discuss why you've made them more smart, perhaps reflect on why you didn't do this in the first place. Or you could just include a table of some projects and not even mentioned that you did them yourself, if you prefer. If you don't want to discuss it. Interesting. Yeah, I didn't like the conclusion that you don't need to. You don't need to hand in the group work. You're not being compared or assessed relative to your group. So what you hand in is treated independently and on its own. Okay. So you can just hand in a version that is your version entirely, or a version that discusses why you did it differently to the group, because that might be an interesting discussion in. Okay. Oh that's right. Thank you. Yeah, that's what I was going to ask you.

SPEAKER 4
Three ways. So in. But then.

SPEAKER 2
Mass production one.

SPEAKER 3
To.

UNKNOWN
That's way. Because.

SPEAKER 1
You know, let's.

SPEAKER 2
Then you look at these boxes and then you know what? That's what you got, after all. It's really inefficient. 51 of each one kind of sell out the car and then he says don't. Okay, so it's less.

SPEAKER 5
Oh, can I steal your dongle?

SPEAKER 2
I can indeed. Sorry. You'll need that in order to help with picking up trash behind the desk for the whole lecture. I should mention, so there's a camera on you, and the camera is recording from that side of the lectern to hear. So you, if you occupy this.

SPEAKER 6
Occupy that territory.

SPEAKER 3
Excellent. And no further than that. That's kind of, you know.

SPEAKER 2
I mean, this lets you see what you're doing. Good. It's down to go through the slides.

SPEAKER 6
If it's installed.

SPEAKER 2
If that thing turned on. This could be that this isn't done on.

SPEAKER 3
And if you.

SPEAKER 2
Click on that screen there sometimes. You should automatically do it. Dongles in at an extension. Yeah. Okay.

SPEAKER 6
No, it's working out good.

SPEAKER 2
Fantastic.

SPEAKER 6
Think you need anything else? No. I think we are good. Some water there. Excellent. And. Yeah. All set.

SPEAKER 3
So. Yes.

SPEAKER 6
Did I say seven minutes? Seven minutes past.

SPEAKER 3
And so we end to end it.

SPEAKER 6
52552. So what I have got is a.

SPEAKER 2
Q&A thing.

SPEAKER 6
That I can yes I could.

SPEAKER 2
I could just ask those questions to.

SPEAKER 6
You from the audience if that would be something. Whatever looks easiest. I'll try and leave some time for questions at the end. We'll come back at the end and do that. Yes, I'll probably. So I've realised I do actually have a fair amount of kind of the theory in there, which is probably repeating yourself. So I'll probably skim over that fairly quickly to kind of like the outrageous pace. It's all good. Excellent.

SPEAKER 2
You put it on a microphone. That's what I was using. I'm sure the battery's still good in there.

SPEAKER 6
Yes. Sounds good. Rejected the back of the lecture theatre.

SPEAKER 2
So we have some people joining the live stream. Do you see?

SPEAKER 6
Ah, yes, of course, this is the new the new normal. I imagine it's the way it was. What they don't realise is students don't come to matches anyway, whether or not you live stream.

SPEAKER 2
I think that's always awesome.

SPEAKER 6
Yes. Excellent. Cool chatting.

SPEAKER 3
Now. Right, I will.

SPEAKER 6
I'll go sit down somewhere and.

SPEAKER 2
I'll try and tackle.

SPEAKER 6
Oh, you're very welcome to add a bit of interest to the proceedings of. Thank you. Right. What do we say? Seven minutes passed. We're good to go. We're good to go. Hello? Right. I think I'm coming through the speakers. Put your hands up if you can hear me. Watching the people at the back. To see if you can't hear me or if you've fallen asleep. Let's assume you all can hear me. Hi, my name is John. So I, as Ian said, I'm a client director at a company called software. I am also a Warwick graduate. Here's my traditional establishing shot of me standing by the cone, which was still there 17 years ago when I graduated. I originally trained as an accountant. I then taught myself to code. Nine years ago, I moved myself to a company called software, initially as a solution architect and technical lead. These days I'm in a more commercial role, but I still occasionally write code when my teams let me do so. I'll give you the 32nd overview of software. So what we do as a company is that we write software for a whole range of companies from government, private sector through to third sector and charities. We build bespoke systems for people with usually slightly unusual business requirements. And our philosophy as a company is that we think that if our teams are happy and our customers are happy, this will lead to commercial success and this so far at least, has proved true. So we grow fairly regularly, 15 to 20% a year. We've got about 370 people are now spread around the UK and across in a small office in Bucharest. And as a company, we were last week named the best large company to work for in the UK. So hopefully we are doing something right. Come and see us also at your careers fairs we tend to pop up most of them at Warwick, so do come and say hello there. Here's a picture of our people. This was from our company holiday in Sardinia last year, so we try and get the company together for lots of fun stuff outside of work as well. So on the right you can see some of our bands playing, and below that some of our board games evenings as well. We work, as I say, for lots of different clients, various interesting government places like the Cabinet Office and the Home Office, various interesting leisure places like the Royal Opera House and Tate Gallery and then lots of boring financial services, places which are mostly the ones that I look after. A quick disclaimer I am not a project manager. I do not know the theory anywhere near as well as Ian does, and so you're most welcome to ignore a lot of what I say on that matter, and to not write it down in your exams. As noted, what I'm going to try and give you today, though, is a bit of a view where, as a software developer, what this might actually mean for you, and particularly if you want to go ahead and do that as a career. So for the people in the room, who amongst you is thinking of a career as a software developer or software engineer of some kind who's actually thinking about going into this? Excellent. Hopefully this will be particularly meaningful for you, but in the worst case, it will reinforce some of what Ian's just said. So what is project management? From my perspective these days I look after projects. So it's my job to look after about 20 projects at a time and make sure that I know what's going on on them, make sure that the client is happy and the team is happy. As mentioned before, and different people care about different things. So the first thing to remember is that your developers have a very different view on life from the people paying for the work and the people ultimately paying for the work care mostly about when is it going to be done and how much it is going to cost. The developers, however, just want to know what actually should I be doing next? Whereas the users of the software don't actually care about any of that stuff, they've got problems they need to solve, they've got things that they need to do and they really care about it. Solving the problem. The thing with project plans, in my view, is that people tend to see them as a target. So you do all this planning effort, you work out when you want to release and you decide that's a target. That's not how I see it. A project plan is not a target. It is your best prediction of the future. And ultimately, if you miss that target, that is the fault of the project plan. It means you got the plan right. Ultimately, there is an amount of work that has to get done to launch a software project, and that amount of work is going to have to get done. Whatever the original plan that you made says. There's a famous law in industry called Hofstetter Law, which says it always takes longer than you expect, even when you take into account Hofstra law. And that is painfully true in practice. In practice, software delivery tends to go really badly. So here's a some numbers from a survey of 50,000 IT projects. This was done a couple of years ago, but the numbers seem to track over time. Of the 50,000 projects they surveyed, 66% were seen as either a total or a partial failure. That's not a good ratio. Over 31% of projects were cancelled outright in the United States, and actually 17% of projects became existential threats to the companies that were trying to do them. Projects can be absolute disasters and even for large organisations, a couple of large ones that have been in the news over the last few years. I don't know if you heard about TSB banks, IT migration, but they tried due to various mergers away from Lloyds and things like that, they try to switch over to their own IT systems. A couple of years ago it went so badly wrong, they had to halt all of their customer banking for a few weeks, and it caused severe reputational damage and even an existential threat for the business. More recently, just up the road in Birmingham, Birmingham council is now officially bankrupt, and a major contributor to that is a failed migration to a new Oracle ERP. That one. Incidentally, the original project budget was £19 million, which is quite a lot. But now the estimated total costs of completing the work are over 100 million. So that's a project that has gone five times over budget and may well be a substantial factor in a council going bankrupt. So what can we learn from this all? Firstly, the thing I want to say is there's actually no right or wrong way to manage a project and all the ways are good in their own special ways. I'm going to talk a little bit about waterfall. I'm going to whizz through the actual theoretical stuff, because hopefully Ian's just covered all this stuff in the last few lectures. Feel free to interrupt me at any time and ask questions, though, about my particular spin on this. In theory, there's a load of stuff you have to do to build a software. You have to work out what it's going to do, what it's going to look like. You have to actually, at some point write some code. You have to test it, deploy it, and then you have to run it in production, often for dozens, dozens of years. So in theory, you can put it like that. And the hand-offs between these stages in waterfall, they go explicitly in this sequence, and you tend to hand over a pack of documentation or a pack of source code. And that's how communication happens in this world. And if it all goes well, if you know the requirements up front and if you do a good job of design development testing, you end up with some working software at the end. And the wonderful thing about waterfall is if you do know all the requirements up front, you know what's going to be built, you know how to test it. You've got a lovely fixed scope and you've got a plan for the entire project, which means that, you know, at any given moment exactly where you are against the plan. In practice, waterfall does still happen in the real world and particularly at large organisations. A lot of their major projects are delivered on a waterfall basis because they're considered too big and too complicated to deliver using more agile methods. This is a picture of a real waterfall plan from a project that I was involved in a few years back. We were a tiny work stream sitting in some of this bit down here. Hands up if you think this project actually went according to plan. Correct answer. Yes. It didn't. Actually, in this particular case, what happened in practice is that the company sponsoring the project went through a massive kind of merger, acquisition, split up phase in that bit, and the project effectively got completely re planned and sort of cancelled as a result of external business factors. But nevertheless, long before that, it was starting to slip, and particularly the dependencies between the workstreams and the kind of some of the complexity in all these assumptions started to break down. And that does happen in the real world. But there is still intrinsic value to planning. And whether you're doing waterfall or agile, whether you're doing lean, scrum, Kanban, whatever methodology you're choosing, one of the biggest pitfalls of agile is not sitting down at the start of the project and having a think about, great, we're going to build some software, but actually, how does it fit into the bigger picture? How does it integrate with other applications? Who is going to need to see this and sign it off? What are the dependencies? Have we got on systems elsewhere in the organisation? There's a lot of value to thinking about the solution in the round, even if then you manage it in an agile way afterwards. So don't be afraid of proper forward planning if you do it, if you do it for an agile project, there's an old quote again, planning is everything. Plans or nothing. Be willing to throw the plan away, but there's value in the planning. So I wanted to talk to you a little bit about a waterfall project that we did, and spoiler alert, why it went a little bit wrong along the way. As an aside, each year I get involved in about 20 different projects over my software career. I've delivered over 100 software projects now, and one of my favourite things about delivering software projects is that in almost every one, I'm working in a new business, in a new industry, and you get to learn all sorts of things about interesting business domains. So I have just kicked off a project up in Glasgow for a green trading company, and I've learned a lot more about the shipping of Bali than I ever imagined there was to learn. But one of the great things about being a software engineer is you can actually learn the inner workings of a lot of business as you go, and it's really interesting. I wanted to talk to you about a police radio system. So let's imagine that you've got a large football match at a stadium and you've got 80,000 fans attending, and you've got potentially 3 or 400 police officers as part of security around the venue. Every one of those has got a radio, and the actual process of managing those radios is unbelievably complex. Firstly, the security aspects, if you lose a radio, you have to be able to decommission it because you don't want people listening in on police comms. You have to get them all back at the end of the day. But then there are also lots of complex requirements around having people in different groups. So each radio may be part of 3 or 4 different groups based on sort of function, based on geography around the stadium and all of that needs managing. So unsurprisingly, there are IT systems to manage these things. So we were engaged to replace a really legacy system written in V6 that was about to be end of life, which was specifically to manage large events. And the company who was building this came to us, and they dropped a 200 page specification on our desk and said, hello, could you build me one of those, please? And you know, in the waterfall world, that's the spec, you can estimate that and you can go and build it, which is great. So we could estimate that we started building it. We gave what they had asked us to do to the end users, and the result was, well, utter dismay. They really, really, really didn't like it. So what actually went wrong? The problem fundamentally, was that the spec was wrong. The analysis had been written by somebody who didn't use the system. Based on the existing system, and they had basically clicked through all the screens, worked out what functionality was played with them around a little bit, and then kind of written a spec based on that. What it kind of missed, though, is that the way people use the system is often very different from the kind of apparent layout of the system. So they also missed lots of opportunities to improve things as well. So along the way, they could have smoothed out user journeys, smoothed out workflows that made people's jobs easier to do. They also came up with a very complicated security system that allowed them to implement all of the different kind of security use cases, but actually made it overly complicated. It was incredibly flexible and incredibly powerful, but actually incredibly hard to use because you ended up with basically a big grid of groups and radios and had to check 100 different boxes to allocate things. So it didn't think about how users actually wanted to use it. And it also didn't think about the UX and the UI. And these are some screenshots from very similar kind of similar looking applications. We rebuilt this as a lovely web app, but people were actually quite used to tight Informationally dense screens that looked like this, where you can just click through and do stuff. And sometimes actually users don't care about it looking pretty, they just want all the information concentrated into one place. As an aside, usability and the way that you lay out the information is a key non-functional requirement. Have we covered functional, non-functional requirements in the course yet? Nodding. Vigorous nodding. Let me talk about a few of them very quickly. Functional is what it does. Broadly non functional is how it does it. So actually how do you use it. What does it perform like. Particularly if you start adding lots of different lots of new users to it. Is it accessible. So can you use screen readers. Is it kind of high contrast. Can people with visual impairments actually use it? Availability actually when does it need to be up? Does it matter if it's down overnight for any reason. And then also philosophical ones like is it open source or not? And practical ones like how much does it cost? These are really, really, really important. And it's very easy to forget one of these when you're planning upfront. And if you're doing waterfall, you don't find out the implications of that till right at the end of the process. So in this particular case, what should have happened is we should have got early builds of the application in front of users to use and put a feedback loop in that's not based on does it meet the spec, but it is based on the users actually want to use this. The real culprit though, was the spec and not the process. If the spec had been right and had actually talked to the users, it probably would have gone fine as a project. So the real lesson here is not oh, don't use waterfall, it's bad. It's talk to the users. So things to learn. The use cases are more important than the functionality. So actually what it does and how users use it is more important than actually what it can do, because it doesn't matter if it can do it, if nobody wants to use it to do that. Understand your non-functional requirements early. It's remarkably common out there in the industry to see systems which look great in practice in principle. But the second, more than a dozen users log on. They fall over because they weren't planned for the amount of traffic that they actually get given. But also question complexity in journalism. And if there's one thing to take away from this as a professional software developer, it's are you implementing an over general solution to what is actually quite a simple problem? It's great to plan for the future. It's great to plan for multiple use cases, but sometimes it's really tempting to overcomplicate. And also it's often quite fun as a developer to write the complicated thing. So anyway, this particular project, we changed lots of things. We redid a load of the journeys. It got there. They're using it. It's been live for a little while now, but they just weren't thrilled. And the best thing is, when you deliver a bit of software and you see people using it and it's going to make their lives better, and this didn't quite hit that bar in the end. I think I've talked about most of these things. So just a few little quotes to leave you on around waterfall. Again, much of the essence of building your program is actually debugging the specification. And the perfect project plan is possible if one first documents the lists of all of the unknowns, and again at the crux of the waterfall. Agile question. Unknowns fundamentally aren't dealt with very well in classical waterfall. Oh, and finally, the classical thing to do when your waterfall plan is slipping is to cut quality. Don't do that. The bitterness of poor quality remains long after the sweetness of meeting the schedule has been forgotten. So let's move on a little bit and talk about actual agile in practice. So agile, as you probably know by now, was invented by some people who were fed up with waterfalls and they thought they spotted four key principles that would make their lives better as software developers. So they wanted to prioritise individuals over process and tools. So, you know, rather than go for formal sign up processes, just go and talk to the user. They wanted working software over comprehensive documentation. It doesn't matter if you have a detailed formal spec that does everything, they'd rather actually just deliver a piece of software that works. And in a lot of cases, the code is the spec or the unit tests are the spec. They wanted customer collaboration over contract negotiation, and as a commercial person in the software space, it is really, really painful. If you end up in any kind of contractual wrangle over what a system should be doing. Inevitably, it costs more. Inevitably, it is painful for all concerned. So why can't we just collaborate and do the right thing and then finally responding to change over following a plan? And as I said at the start of the last system, do the planning a last section, do the planning, and then chuck it out. And then from there on, focus on responding to change. So you've just done these bits, so I'll skip over them relatively quickly. But back to the six elements of building a software that we raised in the previous section. In this case what you do is condense them down into little phases of analyse a bit, build a bit, deliver a bit, chunked those together, and do that in lots of small iterations. And what that means is if you're delivering in small iterations is two things. One, users get to look at it really quickly, but two, in a lot of systems, you don't need the whole system to actually be useful to people. So what you can do is you can incrementally deliver actual, usable production bits of software that people are genuinely using and is genuinely making their lives better and add more functionality as you go. So typically on agile projects, we manage scope using some kind of backlog. I'm not going to tell you whether it should be Scrum or Kanban or whatever else. As long as somewhere you've got a list of all the things you're meant to do in something like JIRA or Azure DevOps or Trello, then that is absolutely fine. And the theory is that if you know how much stuff is in each ticket, you can estimate each ticket. And the little numbers you can see there on this one are sort of rough estimates in days for how long we think the story is going to take. What that means is we know roughly how much work we've got, roughly when that set of work is going to finish. But we can also be dynamic and we can change as new things come in. So I wanted to talk a little bit about actually practically how you manage this. And one particularly important facet of agile, which is often underreported in sort of the theory, is the importance of the user story. So the user story is a way of writing down a requirement which tries to capture the business context. And the capturing of the business context is really, really important. A user story should be scoped to a small bit of value that can be independently developed, but is useful to a person. And the way you typically break it down is you say as a particular type of user, I want to do something in order to achieve a goal. And the type of the user here is really, really important because it helps to give the developer additional contextual cues and to put themselves in the shoes of the person who's going to be using it. Also, the so that gives you information as well. So if you if you want to say I as, as a financial user, I want to do this so that I can do some I can do some reporting in Excel that gives you some clues about actually what kind of data you want to put out. So you want to put tabular data or CSV data or even an Excel export. But the type of the user and what it's for, if you can give that information to a developer, it starts to let you empathise and empathising with your end users about actually what their problems are. Is hugely important in building something that your users are going to like. So for example, as a customer, I want to sort products by review score so that I can find the best option quickly. As an analyst, I want to export the list of companies to excel so that I can use them in my reports and in that example. If you're a developer, you might then go and talk to the analyst and say, hey, what kind of reports are you doing? What format would be useful? What columns would you like to see? But that kind of focus on how it's going to be used is hugely important in kind of getting it as right as possible. First time. Or as a developer, I want to be noticed when the build fails so that I can fix my mess. So quick exercise for you. This is for all of you to think about. Estimation is really, really hard. We talked about backlogs. We talked about estimates on each ticket. The problem is estimation is really hard. So question for all of you. How long would it take each of you in this room to write Fizzbuzz. So Fizzbuzz you write a program that prints the numbers from 1 to 100, but instead of multiples of three, you print five. Instead of instead of multiples of three, you print fizz instead of multiples of five. You print buzz for numbers, which are multiples of three and five, print fizzbuzz and otherwise just print the numbers. Put your hands up if you think you could write that in an hour or two. This is Computer Science 101. I'm hoping most of you could actually do that. Fun fact if you ask it contractors to try and write this under interview conditions, about 75% of them can't. If that surprises you. Yeah, it surprised me too, but it's actually surprisingly hard to write even this kind of basic thing under interview conditions. Apparently. Um, this is fairly understandable. So let's go for something a little bit harder. How about a to do list? So let's imagine that you wanted to clone Todoist or one of those sorts of things. You write a little program with a few screens. It tracks to do items due dates you can put in name, priority detail, etcetera, etcetera. You store it in a database, have a simple web user interface, a nice kind of view with all the to do items sorted by date or priority. Or is it done or not? And a little daily email digest. So put your hands up if you think you could get that done within a month on your own. What about? Keep your hand up if you think you could do it in a week. I think that's about plausible. If you could do it in a day. A day's maybe pushing it with a with a kind of nice, like, Django framework or something. You might be able to actually churn that out. But yeah, this is kind of order a few weeks maybe to kind of get most of that functionality done. That is still the kind of understandable option. So what about if you had to rewrite Twitter? Hands up. If you could think you could do Twitter within a month. Yeah. Probably not. What about Twitter? Within a year? Anyone think you could come up with a plausible Twitter clone within a year? I think with the basic functionality, maybe just about. It's just short messages. But what you'll find with Twitter again is if you go behind the scenes, there's actually an unbelievable amount of complexity. And even now, I think Twitter still has about 550 tech people on staff full time, writing code on what looks like a simple platform and what you'll find with most big systems is as soon as you look behind the simple UI, there's a huge amount of stuff going on to make it performant, to comply with regulations, to deal with kind of commercial advertising revenue, all those sorts of sides of the business. And actually things get really complicated, really fast. And what this means is if someone drops a spec for a big system or ask you to help them build the next Facebook, it's actually really, really hard to estimate. As a developer, the most important thing is that you have a say in the estimates. So whether you're working in whether you're trying to plan a waterfall project or whether you're trying to execute an agile project, the thing that really sucks as a developer is trying to hit someone else's estimates. So at software, what we try and do is make sure the whole team are engaged in the estimates, because that means everyone gets a say, but also that we can learn from other people's thinking in the team. So we'll often in a planning situation, get to a point where somebody says, well, actually, I saw this problem over here and it was harder because of these reasons. So you can kind of bring your experience into it. We try and engage the whole oops, wrong button. We can we try and engage the whole team in estimating the backlog. So in going through all the stories and working out how hard they are, we try and get the whole team together through a backlog session about once a month in order to go through the estimated stories and say, right how hard this is and what are people's perspectives on how you might implement it. We've got a few different ways that we engage people, and I'd really, if you ever get into a project doing an agile delivery, I'd really encourage you to try out some of these approaches because they work really well. First of these is planning poker. So what you do is you get a little set of cards with numbers on. Traditionally we use Fibonacci numbers. So one, two, three, five, eight, 13, etcetera. Because what we actually find is that your accuracy as the complexity of a story increases roughly follows the Fibonacci numbers, you won't be able to tell the difference between, you know, if you have eight and 13, that's about as accurate as you can be when a story is getting to that kind of size. So there's no point having eight, nine, ten, 11, 12, you might have eight, you might have 13, you might have 21. But actually the curve of the Fibonacci sequence quite neatly matches how accurately you as a developer can guess how hard something is. So everyone has a deck of Fibonacci numbers. Each feature is discussed, people ask questions and clarifications, they put a card on the desk, and then everyone turns them over at once. And what that means is you get a blind read on why everyone thinks it's either really easy or really hard. The really interesting stories are the ones where there's a big spread of numbers and you get a few threes and a few a few thirteenths. Those are the ones which you then discuss as a team and actually work out well. Why do you think it's hard? Why do you think it's easy? And you then converge on a number. But what that also does is as well as giving you probably a more accurate estimate, it aligns the team's thinking. It lets the team learn from each other, and it sort of builds consensus. Other options and depending on like the kind of estimate you need, whether it's sort of days or whether it's kind of relative sizing, you can also use T-shirt sizing where you have extra small, small, medium large and extra large. And again, for each story you put them into those buckets. And what that means is when you start development, you've got things roughly arranged according to size. And as you start tracking your velocity, you can start to extrapolate that, well, on average, an extra small takes a day. On average, a medium takes four days. On average, a large takes ten days, an extra large 20 days. And you can start to actually kind of come up with a fairly accurate estimation of how long a project's going to take. Based on that final option is a good old bubble sort. You've presumably all done bubble sort as an example of what not to do in your algorithms classes. It works quite nicely, though, if you're trying to estimate stories. If you've got a manageable number of stories, say 30 to 50, what you can do is put them all on a post-it note and just bubble sort until you feel like they're in the right order. And then as you get going on the project, you can fit those using a kind of, again, a rough Fibonacci shaped curve and come up with a relatively accurate estimate after you've done maybe 1,015% of them as to how long the project is going to take. But the important thing with all of those is that you get the developers in a room to discuss the implementation and to get their buy in. What else? Then? Once you've got the things estimated, then actually you've got various options. So scrum is actually what we mostly use here at software. You've just done scrum. So I'm not going to talk you through a theory, but what works really nicely in scrum is just the regular cadence of it. And because we are developers for hire, so because clients will come and pay us money to build them software, what works really nicely about scrum for us is that it's got this regular cadence of stand up and dev each day, each either 2 or 4 weeks. You can then demo that to the client. You can show them that you're actually spending their money well, and then you can kind of internally plan and reflect and work out what to do next. So we quite like the scrum cadence. And yeah, it works quite nicely over the length of our sorts of projects where scrum starts to fall down as if you've got multi-year projects and you end up with a very crafty backlog. Our projects are typically three months to a year, and what we find is over that sort of period, actually, scrum works quite nicely. It's quite good. You can get through a good size of backlog and you'll end up flushing it on a multi-year project which gets to two, three, four years. What you find is that in the backlog, you end with a big well, you end up with a big backlog of items that are kind of low priority that will probably never get get to, and that starts to kind of drag down the mood of the team. And also it gets quite hard to prioritise and decide what to do, but also quite hard to decide when to drop those features. So let's talk a little bit about an agile case study as well then. So this one in particular was for Lonely Planet. So they're based in Australia and they're still just about a thing. They've they took a bit of a hit during Covid, unsurprisingly. But fundamentally they do travel guides for lots of different jurisdictions. So we were helping them to replace their shopfront with something a bit more modern and easy to maintain. And they explicitly wanted to run this agile, which was great. So we took a trip over to Australia to go and meet them, and indeed we left the project manager over in Australia to be on the ground managing the work throughout the course of the project. And it started really well. So we had genuinely cross-functional teams. So cross-functional means people from different business areas. We had people who were kind of developers, managers, designers, business users from the kind of product teams, from the finance teams. And we had a really good cross-section of all the people who cared about any aspect of building or operating this platform. Collaboration was great. So we were based in their office for the start of it. And indeed, as I say, you had a project manager there throughout and it meant we could wander around and talk to people in the warehouse or in the finance team or in their marketing departments, and really get a feel for what they wanted. And the team culture sort of developed really nicely. So we had a few unique customs and distinctive artefacts. That's a picture of the build screen for this project. So we actually misappropriated a traffic light that we found in a tip somewhere, and we set it up so that it went green when the build succeeded, or amber when the build was going on, or red when the build failed. And as an aside, it's always a good sign when you see your project teams starting to develop little quirks because it means they're kind of gelling as a team. However, it started to snarl up, so agile in theory is great. It's a really good way of getting a kind of fast flow of work through a system and to get tickets done. But it started to snarl up. So part of that is that some of the initial analysis that came from the client actually needed redoing. It didn't quite capture what they wanted, and a lot of the stories that they'd written only made sense as part of a larger journey. So, for example, they'd written some stories about promotion codes, but they only really made sense as part of other purchase journeys, which made it quite hard to pick up some of the initial set of stories that they'd given us. I'm also, they didn't like signing off small bits of the system. What we found is we put a little bit in front of them, and because of that complexity about where it fits into the overall story, they'd say, yeah, we like that, but we're not quite ready to sign it off. So we ended up with a bit of a build up of tickets in the kind of awaiting sign off column on our on our scrum board. And what this meant as well is that we had quite a lot of work in progress in code as well. And one of the bits where agile can go quite badly wrong is if you end up with too much work in progress and particularly work in progress, that's sitting off on branches and it's not merged into master. I assume we've done source control by this point, and you're kind of aware of branching and merging strategies and those sorts of things. Every day that a branch sits, not merged into master, it slowly rots. Branches have a bit of a half life, after which they're almost impossible to merge back in. And if you pick up a branch that was branched off and worked on six months ago, you might as well start again from scratch because the system would have moved on so much, there's very little chance you'll be able to merge it in. You will be quicker to rewrite it. So what that meant was that for this particular project, each after several rounds of retesting, we had to keep all the branches up to date based on what was going on on master, and that ended up with quite a lot of overhead for the team. In delivering this hand on heart. We also overcomplicated bits of the system as well. So as I mentioned earlier, sometimes a general solution is really interesting. So building a framework to do promotion codes is great fun because you can write a rules engine to do all sorts of different bits. You get one free 20% off all those sorts of offers and indeed the way that they interact in the checkout, making those in the right order is really interesting programming challenge, but actually they only really wanted 4 or 5 different promotion codes, and we'd have just been quicker to hard code those in the system. So we overcomplicated bits of this as well, because we weren't quite keeping enough kind of architectural oversight on what people are doing. So things that we learned from that engagement, firstly, writing good user stories is really hard. Don't start development until you have done some of that waterfall style upfront planning. Keep your work in progress under control because juggling branches is really expensive and also, as always, question complexity. As a developer, if something seems needlessly overcomplicated, it probably is. So we still got it delivered ahead of schedule. At the end, the client was happy, but it was still painful at times. So one particular technique you've just covered, which would really have helped to mitigate this is Cambon. The important thing about Cambon is that you typically have a limit on each of the possible states that a ticket can be in on that project. If we agreed with the client we were going to run this Cambon and had a waiting sign of column with a limit of, say, five stories. It would have effectively blocked development and given us the excuse to kind of escalate it to the client and really push them to sign things off. So Cambon works great as a kind of fast flow sort of event. What we find is, as I say, because we are being paid by clients to develop and we'd like to show regular progress. Scum, scum scrum often suits us better. But Kanban, we find where we do get to use it. It is probably better at delivering more stuff for less money because it optimises for that continual flow and that kind of work in progress limit for each column does mean you avoid all sorts of kind of potential problems with, with, with kind of backups in the process as well. So as an aside, I'd like to talk about cargo cults of World War two. Obviously, this is a bit of a cautionary tale about agile in large organisations in practice. So during World War two, there were lots of US Army bases in Melanesia. So what the US would do is they would find a small island, they would put an airstrip on there, and they'd use it as a staging post to ferry sort of logistical items around the the Pacific region. Some of those islands had existing islanders, and to keep them sweet, what would happen is the US Air Force personnel would give them sort of tin goods or food or clothes or medical supplies or things like that. And actually, for a lot of islanders, it really changed their lives for the better. However, at the at the end of the war, all of those bases got got decommissioned, planes stopped coming in, Islanders stopped getting all of these kind of wonderful Western packaged goods, and they wanted to get some of that back. And what happened on a lot of those Melanesian islands is actually cargo cults sprung up. So a cargo cult is a set of people who are trying to summon those planes to come back and bring them goods by following the form of what they've seen. So observers to those islands would actually see people with those big glowing sticks having made effigies of planes, trying to kind of convince the planes to come back, because that's what they had observed. And they thought that if they did the same thing, they would get the same results. Which leads me on to cargo cult agile. One thing I'd really like you all to be watching out for in the real world is people who say that they're doing agile, but they're not, and this happens most in large organisations. So as a few examples of the sorts of things that we've seen in large banks, we had large banks as a large bank example, we worked for a large bank that had a 70 point checklist for each code review, and in theory, for each code review, you check off 70 points. And the reason that evolved is that every time a bug made it into production, something was added to the checklist to stop it happening again. But this ended up putting a massive process barrier and meant it take absolutely ages to get any any release done. We also worked with a large insurer who employed an offshore test team. Every bit of code that we completed, we had to write extensive documentation so that the team could test it, and we weren't allowed to write unit tests on that because we'd be marking our own homework in inverted commas. The police radio project, actually, we discussed earlier, was actually meant to be an agile project. We were initially asked by a client to deliver agile. Um, but in the end, they gave us a massive spec and regardless of how we deliver it, it was it was really a waterfall project. And a lot of projects you see in larger organisations don't actually involve the users. Finally, we're about a year into running a large agile program within a waterfall finance transformation program. So it had to be agile because there was no specification available. And often large organisations will say, well, there's no spec, let's do it agile. But they still want really to have agile. They still want really to have waterfall. They still want to know when it's going to be done. They still want to know how long it's going to take, how much it's going to cost. And what that means is that velocity ends up being a stick used to beat developers, and not actually a kind of useful predictive tool. And all of these happen in large organisations on projects that claim to be agile. And all of these kind of directly contradict everything that the Agile Manifesto was meant to be about. So do watch out for those. If you find yourself working on an agile project that really isn't, do try and have a think about, well, is this really waterfall? And if so, what should we be doing on waterfall? Because sometimes the best thing to do is, if you know it's not an agile project is to say, well, let's do a plan, let's actually work it through, let's figure out what the spec is. Let's do proper estimates based on that, because there's nothing worse than being on a kind of water fragile project which has the worst of both worlds. As a quick aside, it's also worth having a think about how different different project management techniques relate to different, different commercial models. So because we work for hire, we generally work in one of two ways. We do a fixed price work where they give us a spec and we can estimate that up front. And actually that tends to align quite nicely to waterfall in a lot of cases, except for the fact the spec is often wrong and often expectant, often acceptance in the end, and ultimately payment is based on that spec which causes problems. And also then change is always expensive in any project planning exercise change is always expensive. We also work on a time in materials basis where people just pay us for all of the time spent, and what that means is they can change the requirements all they like. They can mix things up halfway through the projects, they can do whatever they like ultimately, and they just pay us for the time spent. The problem is they often don't like to do that. They don't like to feel like they're paying extra because they've changed their minds. It does make things unpredictable, and it does mean you have to kind of engage and manage the project. And ultimately, as a developer, the responsibility is with you to use your knowledge and your experience to manage people's expectations and to kind of foresee the areas where they're going to change their minds or where problems might, might arise and to engage them in that. Ultimately, there is no right model for management, either project management or for commercial engagement. Only the right behaviours and projects always go better where you get the right engagement. So as an example of where something started going wrong but actually got fixed really well, I wanted to talk about some work that we did for David Lloyd. So they brought us in to rewrite their in-house booking system. So David Lloyd are a large gym company. They've got a few hundred gyms around the UK. They've got a kind of member booking system where you can book classes or tennis courts or all those sorts of things. So they wanted a new member facing portal, and they called us up the day after they fired their existing development partner, which is always a good sign. So begin development. In theory, this actually kind of started really well. We picked up an existing backlog from the previous development partner. We started kind of measuring our velocity, started working out actually how long is going to take, and found very quickly that the lovely burndown chart that we've created got completely and horribly inaccurate. So what actually went wrong? Kind of everything. Agile doesn't work when the foundations that you're building on are too broken. So what we found was that the code base we inherited was a shambles. For a start, it was written in PHP, but actually there were several multi thousand line classes, several million lines of tangled PHP, some of the functionality that was meant to be completed and which other bits of the backlog depended on actually either didn't work or didn't exist at all. And obviously they told the client it worked, but it actually wasn't even there. But then within the actual code base. Everything manipulated global state and again, practical takeaways. As developers, the one thing you should avoid is mutable global state, because it tends to mean that any changes you make will break things a long way away. You end up with a lot of cross coupling, and this was one tangled mess of mutable global state. But also back to NFS. The performance was orders of magnitude out, so they released their classes and tennis courts at about 8 a.m. each morning. And you log into the system and you book them. That means that hundreds of users log in at the same time and try and book a court. But what we found is if all four people on the development team logged in at the same time, the system would crash so it couldn't cope with a dozen users, let alone a few hundred. And this was resulting to a lot of angry calls to their reception team. As an example of why this was happening, let me show you what the industry best practice is for multiplying two small numbers together. So first create a database table. Just like that. What you then do is you validate your inputs. You make sure that your users are not trying to like, multiply irrational numbers or anything. But yeah, create a database table, check that your numbers are actually numbers and then stick them into a database table. Create a random key, Chuck it all in there, generate some dynamic SQL which is actually going to kind of execute the query in a nice flexible way. Select the results out of that database table, write the results back into the database table, select those results out of the database table and clean up. And this was happening multiple times for reasons we never quite got to the bottom of in in every journey. This is the kind of thing you inherit. And what it means is that any estimates you come up with are going to hit something like that, where you then have to try and work out what they're doing and why, and suddenly a one day story takes a week to unpick. Oh, that's more code. Oh yeah. There's there's the actual there's the actual PHP code that we, we had to figure out and replace. It also supported multiple small integers because two obviously isn't general enough. What became very quickly apparent is in spite of the fact that it was an agile project and that David Lloyd really on board with agile in principle, it was very hard to build trust. And ultimately agile comes down to building trust. So we took a step back with them and we started to actually explain what was going on and give them an honest assessment of the codebase and the problems that they were facing. So we started to try and articulate the problem, to explain why things are bad, why everything is slipping, and which assumptions that we discussed with them up front were being broken day on day to day. We also then try to quantify the problem as we started to work out the delta between our estimates and how long things actually took. We could then start to support revise timings and costs with actual hard evidence. But the most important thing was that as we started to fix these problems, we did actually deliver improvements. So they started to see gradual improvements to the system bit by bit. So having watched an agile project go completely off the rails with their previous supplier, they at least started to see gradual, incremental improvements in their business systems. But we also explicitly asked them to allow us to invest in going faster. So technical debt and process debt and lots of other things that made the teams take longer than they should do. We explicitly asked for time to put in automated testing, automated deployments, automated regression checks, that kind of system level, automated load tests and things like that, that would allow us to kind of actually accelerate delivery overall and where it got to in the end. Actually, they were really happy. In about two years, we rewrote most of the PHP monolith as a set of nice Java services, which performed really well and sort of solved a lot of the underlying problems. So they were super happy in the end. But it did take that kind of building of trust, and it did take for them to trust us. So let me wrap up here. Key bits and pieces. Put it in front of actual users as early as possible, even if it means, as a developer, take your laptop, walk over to the person who's going to be using it desk. Show them something, make them play with it and say, what do you think? There's no substitute for doing that. Don't forget your non-functional requirements and think about all of those at the start of the project. How many people are going to be using it? How accessible does it need to be? And all those sorts of things. But finally, be aware of methodologies, zealots and cargo cultists. There is no one right way to deliver a software project, and if anyone tells you theirs is the only true way, it's better to not believe them. Ultimately, if you know the scope and can track your progress, that is 90% of what you need. I think that's me. And I think I've got three minutes for any questions. So any questions in the room or on the fancy laptop system? Hello. How do you encourage developers to write maintainable code when they're going to be off the project in three months? That's a great question. The thing that we do mostly for that is to hire the right people. So we select very carefully for people who care about what they do. We went through an exercise a few years back of working out what our corporate values were, which in a lot of places is a bit of fluff and nothing. But in ours one of the values was caring about what we do, and we distil that down from actually what happens in the company rather than something kind of imposed by management. It's so it's who you select for the company, but also the culture of the teams. So one of the things that we do is that we don't cut corners, even if we've got a deadlines coming up, if we're not going to hit the deadline, we have a conversation with the client. We don't cut quality because we know it will come back and bite us. So it's yeah, it's just a part of the culture of the company. And it's one that the management of the company is very careful to kind of maintain.

SPEAKER 2
One. Which is your favourite agile variant?

SPEAKER 6
My favourite agile variant. I think. My favourite. My favourite agile variant is probably a kind of really lean Kanban. I had a project that I was actually involved in writing code for about 5 or 6 years ago, where we just had a small team of people, a little Kanban board, and were able just to whiz through functionality and really get into the kind of flow of releasing things and actually having a team. It was a short project. It was a couple of months, but we basically had a team of three of us in a flow state for about two months, just churning things out, and it just felt really nice. It felt less process heavy. We still had little retros from time to time, but it just felt really free and easy. And because it was a time and materials project, we didn't have to worry about commercials as well. So when it's working nicely, I really lean. Cameron. Cool. I think we are on time. Thank you all very much indeed. Right? Have I managed to mute that? Maybe.

SPEAKER 3
Yeah. You guys.
